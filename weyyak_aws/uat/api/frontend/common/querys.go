package common

import (
	"strconv"
)

func ContentsByPlansQuery(countryId, PlanId string) string {
	query := "SELECT c.content_key,c.id,c.content_tier,c.created_at from content c join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=" + countryId + " and crp.subscription_plan_id =" + PlanId + " group by c.content_key,c.id,c.content_tier,c.created_at UNION SELECT c.content_key,c.id,c.content_tier,c.created_at from content c join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null and crc.country_id=" + countryId + " and crp.subscription_plan_id =" + PlanId + " group by c.content_key,c.id,c.content_tier,c.created_at"
	return query
}
func ContentRatingQuery(contentkey string) string {
	query := "SELECT round(c.average_rating::numeric,1) as average_rating,cpi.transliterated_title,c.content_type,pi1.duration as length,c.id,c.content_key,c.content_tier,cr.digital_rights_type from content c join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and c.content_key = " + contentkey + " group by  c.average_rating,cpi.transliterated_title,c.content_type,pi1.duration,c.id,c.content_key,c.content_tier,cr.digital_rights_type UNION SELECT round(c.average_rating::numeric,1) as average_rating,cpi.transliterated_title,c.content_type,(select sum(pi1.duration) from playback_item pi1 join episode e on e.playback_item_id =pi1.id join season s on s.id=e.season_id join content c on c.id =s.content_id where c.content_key =" + contentkey + ") as length,c.id,c.content_key,c.content_tier,cr.digital_rights_type from content c join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null)  and c.content_key = " + contentkey + " and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null group by c.average_rating,cpi.transliterated_title,c.content_type,pi1.duration,c.id,c.content_key,c.content_tier,cr.digital_rights_type"
	return query
}
func MultitierContentQuery(contentId string, language string) (string, string, string, string) {
	groupBy := "c.content_key,c.content_type,s.english_meta_title,s.arabic_meta_title,s.english_meta_description,s.arabic_meta_description,c.created_at,c.modified_at,cpi.transliterated_title,cpi.arabic_title,atci.age_group,atci.english_synopsis,atci.arabic_synopsis,atci.production_year,cpi.original_title,pi1.duration,pi1.video_content_id,cr.digital_rights_type,e.number,s.number,s.cast_id,pi1.scheduling_date_time,cr.digital_rights_start_date,cr.digital_rights_end_date,s.has_poster_image,s.has_details_background,s.has_mobile_details_background"
	fields := "s.cast_id,c.content_key as id,c.content_type,c.created_at as inserted_at,c.modified_at as modified_at,cpi.transliterated_title as friendly_url,atci.age_group as age_rating,atci.production_year,(select sum(pi1.duration) from playback_item pi1 join episode e on e.playback_item_id =pi1.id join season s on s.id =e.season_id where s.content_id ='" + contentId + "') as length,min(pi1.video_content_id) as video_id,cr.digital_rights_type,pi1.scheduling_date_time,cr.digital_rights_start_date,cr.digital_rights_end_date,s.has_poster_image,s.has_details_background,s.has_mobile_details_background"
	if language == "en" {
		fields += ", s.english_meta_title as seo_title,s.english_meta_description as seo_description,cpi.transliterated_title as title,cpi.arabic_title as translated_title,atci.english_synopsis as synopsis"
	} else {
		fields += ", s.arabic_meta_title as seo_title,s.arabic_meta_description as seo_description,cpi.arabic_title as title,cpi.transliterated_title as translated_title,atci.arabic_synopsis as synopsis"
	}
	join := "join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "c.id=? and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null and crc.country_id=?"
	return fields, join, Where, groupBy
}

func MultitierContentQueryWithoutEpisode(contentId string, language string) (string, string, string, string) {
	groupBy := "c.content_key,c.content_type,s.english_meta_title,s.arabic_meta_title,s.english_meta_description,s.arabic_meta_description,c.created_at,c.modified_at,cpi.transliterated_title,cpi.arabic_title,atci.age_group,atci.english_synopsis,atci.arabic_synopsis,atci.production_year,cpi.original_title,cr.digital_rights_type,s.number,s.cast_id,cr.digital_rights_start_date,cr.digital_rights_end_date,s.has_poster_image,s.has_details_background,s.has_mobile_details_background"
	fields := "s.cast_id,c.content_key as id,c.content_type,c.created_at as inserted_at,c.modified_at as modified_at,cpi.transliterated_title as friendly_url,atci.age_group as age_rating,atci.production_year,(select sum(vt.duration) from variance_trailer vt join season s on s.id = vt.season_id where s.content_id ='" + contentId + "') as length,min(vt.video_trailer_id) as video_id,cr.digital_rights_type,cr.digital_rights_start_date,cr.digital_rights_end_date,s.has_poster_image,s.has_details_background,s.has_mobile_details_background"
	if language == "en" {
		fields += ", s.english_meta_title as seo_title,s.english_meta_description as seo_description,cpi.transliterated_title as title,cpi.arabic_title as translated_title,atci.english_synopsis as synopsis"
	} else {
		fields += ", s.arabic_meta_title as seo_title,s.arabic_meta_description as seo_description,cpi.arabic_title as title,cpi.transliterated_title as translated_title,atci.arabic_synopsis as synopsis"
	}
	join := "join season s on s.content_id = c.id join content_primary_info cpi on cpi.id = c.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join variance_trailer vt on vt.season_id = s.id join content_rights cr on cr.id = s.rights_id join content_translation ct on ct.id = s.translation_id full outer join content_rights_country crc on crc.content_rights_id = cr.id"
	Where := "c.id=? and c.status = 1 and c.deleted_by_user_id is null and  (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and crc.country_id=?"
	return fields, join, Where, groupBy
}
func SeasonDetailsQuery(language string) (string, string, string, string) {
	fields := "s.id,s.season_key,s.number as season_number,cr.digital_rights_type,ct.language_type,s.has_poster_image,s.has_details_background,s.has_mobile_details_background,atci.intro_duration,atci.intro_start,atci.outro_duration,atci.outro_start"
	if language == "en" {
		fields += " ,s.english_meta_description as seo_description,s.english_meta_title as seo_title,cpi.transliterated_title as title,atci.english_synopsis as synopsis"
	} else {
		fields += " ,s.arabic_meta_description as seo_description,s.arabic_meta_title as seo_title,cpi.arabic_title as title,atci.arabic_synopsis as synopsis"
	}
	join := "join content c on c.id=s.content_id join episode e on e.season_id = s.id join content_primary_info cpi on cpi.id =s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi2 on pi2.id = e.playback_item_id join content_translation ct on ct.id =pi2.translation_id join content_rights cr on cr.id =pi2.rights_id join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "c.id=? and s.status =1 and s.deleted_by_user_id is null and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and (pi2.scheduling_date_time <=NOW() or pi2.scheduling_date_time is null) and crc.country_id =?"
	groupBy := "s.id,s.season_key,s.number,s.english_meta_description,s.english_meta_title,cpi.transliterated_title,cr.digital_rights_type,ct.language_type,s.arabic_meta_description,s.arabic_meta_title,cpi.arabic_title,atci.arabic_synopsis,atci.english_synopsis,atci.intro_duration,atci.intro_start,atci.outro_duration,atci.outro_start"
	return fields, join, Where, groupBy
}
func SeasonDetailsQueryWithoutEpisode(language string) (string, string, string, string) {
	fields := "s.id,s.season_key,s.number as season_number,cr.digital_rights_type,ct.language_type,s.has_poster_image,s.has_details_background,s.has_mobile_details_background,atci.intro_duration,atci.intro_start,atci.outro_duration,atci.outro_start"
	if language == "en" {
		fields += " ,s.english_meta_description as seo_description,s.english_meta_title as seo_title,cpi.transliterated_title as title,atci.english_synopsis as synopsis"
	} else {
		fields += " ,s.arabic_meta_description as seo_description,s.arabic_meta_title as seo_title,cpi.arabic_title as title,atci.arabic_synopsis as synopsis"
	}
	join := "join content c on c.id = s.content_id join content_primary_info cpi on cpi.id = s.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join content_translation ct on ct.id = s.translation_id join content_rights cr on cr.id = s.rights_id join content_rights_country crc on crc.content_rights_id = cr.id"
	Where := "c.id=? and s.status =1 and s.deleted_by_user_id is null and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id =?"
	groupBy := "s.id,s.season_key,s.number,s.english_meta_description,s.english_meta_title,cpi.transliterated_title,cr.digital_rights_type,ct.language_type,s.arabic_meta_description,s.arabic_meta_title,cpi.arabic_title,atci.arabic_synopsis,atci.english_synopsis,atci.intro_duration,atci.intro_start,atci.outro_duration,atci.outro_start"
	return fields, join, Where, groupBy
}

func OnetierContentQuery(contentId string, language string) (string, string, string, string) {
	groupBy := "c.content_key,c.content_type,c.english_meta_title,c.arabic_meta_title,c.english_meta_description,c.arabic_meta_description,c.created_at,c.modified_at,cpi.transliterated_title,cpi.arabic_title,atci.age_group,atci.english_synopsis,atci.arabic_synopsis,atci.production_year,cpi.original_title,cv.has_all_rights,pi1.duration,cv.id,pi1.video_content_id,cr.digital_rights_type,c.cast_id,pi1.scheduling_date_time,cr.digital_rights_start_date,cr.digital_rights_end_date,c.has_poster_image,c.has_details_background,c.has_mobile_details_background"
	fields := "c.cast_id,c.content_key as id,c.content_type,c.created_at as inserted_at,c.modified_at as modifiedAt,cpi.transliterated_title as friendly_url,atci.age_group as age_rating,atci.production_year,cv.has_all_rights as geoblock,cv.id as content_version_id,pi1.duration as length,min(pi1.video_content_id) as video_id,cr.digital_rights_type,pi1.scheduling_date_time,cr.digital_rights_start_date,cr.digital_rights_end_date,c.has_poster_image,c.has_details_background,c.has_mobile_details_background"
	if language == "en" {
		fields += ", c.english_meta_title as seo_title,c.english_meta_description as seo_description,cpi.transliterated_title as title,cpi.arabic_title as translated_title,atci.english_synopsis as synopsis"
	} else {
		fields += ", c.arabic_meta_title as seo_title,c.arabic_meta_description as seo_description,cpi.arabic_title as title,cpi.transliterated_title as translated_title,atci.arabic_synopsis as synopsis"
	}
	join := "join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "c.id=? and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null)  and crc.country_id=?"
	return fields, join, Where, groupBy
}
func MovieDetailsQuery(language string) (string, string, string, string) {
	groupBy := "crc.content_rights_id,cr.digital_rights_type,cv.order,crp.subscription_plan_id,cpi.transliterated_title,c.created_at,cpi.arabic_title,cv.id,cv.intro_duration,cv.intro_start"
	fields := "cv.id,c.created_at as insertedAt,cr.digital_rights_type,cv.intro_duration,cv.intro_start"
	if language == "en" {
		fields += ", cpi.transliterated_title as title"
	} else {
		fields += ", cpi.arabic_title as title"
	}
	join := "join content_primary_info cpi on cpi.id =c.primary_info_id join content_variance cv on cv.content_id=c.id join playback_item pi on pi.id =cv.playback_item_id join content_rights cr on cr.id =pi.rights_id join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id"
	Where := "content_id =? and cv.deleted_by_user_id is null and cv.status=1 and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=?"
	return fields, join, Where, groupBy
}
func ContentActorsQuery(language string) (string, string, string, string) {
	fields := "cc.main_actor_id,cc.main_actress_id"
	if language == "en" {
		fields += ",string_agg(CAST(a.english_name AS varchar), ',' order by a.english_name) as actors "
	} else {
		fields += ",string_agg(CAST(a.arabic_name AS varchar), ',' order by a.arabic_name) as actors"
	}
	join := "full outer join content_actor ca on ca.cast_id=cc.id full outer join actor a on a.id=ca.actor_id"
	groupBy := "cc.main_actor_id,cc.main_actress_id"
	Where := "cc.id =?"
	return fields, join, Where, groupBy
}
func ContentGenresQuery(language string) (string, string, string, string) {
	var fields string
	if language == "en" {
		fields += "g.english_name as name"
	} else {
		fields += "g.arabic_name as name"
	}
	join := "join content_genre cg  on cg.genre_id=g.id join content c on c.id=cg.content_id"
	groupBy := "g.english_name,g.id,cg.order"

	Where := "c.id =?"
	return fields, join, Where, groupBy
}
func SeriesGenresQuery(language string) (string, string, string, string) {
	var fields string
	if language == "en" {
		fields += "g.english_name as name "
	} else {
		fields += "g.arabic_name as name "
	}
	join := "join season_genre sg on sg.genre_id  = g.id join season c on c.id = sg.season_id "
	groupBy := "g.english_name,g.id,sg.order"

	Where := "c.id =?"

	return fields, join, Where, groupBy
}
func ContentPlansQuery(content_type int) (string, string, string) {
	fields := "crp.subscription_plan_id"
	var join, Where string
	if content_type == 1 {
		join = "join playback_item pi2 on pi2.id =cv.playback_item_id join content_rights_plan crp on crp.rights_id = pi2.rights_id"
		Where = "cv.id =?"
	} else {
		join = "join season s on s.rights_id = crp.rights_id join content c on c.id =s.content_id"
		Where = "s.id =?"
	}

	return fields, join, Where
}
func SeasonEpisodesQuery(language string) (string, string, string, string) {
	fields := "e.id as episode_id,e.episode_key as id,c.content_key as series_id,e.number as episode_number,min(pi1.video_content_id) as video_id,pi1.duration as length,e.created_at as insertedAt,cr.digital_rights_type as digital_rights_type,e.has_poster_image,cpi.intro_start,cpi.outro_start"
	if language == "en" {
		fields += ",e.synopsis_english as synopsis,cpi.transliterated_title as title"
	} else {
		fields += ",e.synopsis_arabic as synopsis,cpi.arabic_title as title"
	}
	join := "join season s on s.id =e.season_id join content c on c.id = s.content_id join content_primary_info cpi on cpi.id = e.primary_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id =pi1.rights_id"
	Where := "e.season_id=? and e.status =1 and e.deleted_by_user_id is null and (pi1.scheduling_date_time <= now() or pi1.scheduling_date_time is null)"
	//and (e.scheduling_date_time <=NOW() or e.scheduling_date_time is null)"
	groupBy := "e.id,c.content_key,pi1.duration,cr.digital_rights_type,e.synopsis_english,cpi.transliterated_title,cpi.arabic_title,e.synopsis_arabic,pi1.scheduling_date_time,cpi.intro_start,cpi.outro_start"
	return fields, join, Where, groupBy
}
func GetSeriesQuery(language string) (string, string, string, string) {
	fields := "c.id as content_id,min(s.id::text) as season_id,c.content_key as id,c.content_tier,min(pi1.video_content_id) as video_id,Replace(lower(cpi.transliterated_title), ' ', '_') as friendly_url"
	if language == "en" {
		fields += ",cpi.transliterated_title as title"
	} else {
		fields += ",cpi.arabic_title as title"
	}
	join := "join content c on c.primary_info_id=cpi.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=s.rights_id join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and c.status = 1 and c.deleted_by_user_id is null and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null and crc.country_id=? and lower(c.content_type) = ?"
	groupBy := "c.id,c.content_key,cpi.transliterated_title,cpi.arabic_title,c.created_at"
	return fields, join, Where, groupBy
}
func GetMoviesQuery(language string) (string, string, string, string) {
	fields := "c.id as content_id,cv.id as season_id,c.content_key as id,c.content_tier,min(pi1.video_content_id) as video_id,Replace(lower(cpi.transliterated_title), ' ', '_') as friendly_url"
	if language == "en" {
		fields += ",cpi.transliterated_title as title"
	} else {
		fields += ",cpi.arabic_title as title"
	}
	join := "join content_primary_info cpi on cpi.id=c.primary_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "c.status = 1 and cv.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=? and lower(c.content_type)= ?"
	groupBy := "c.id,cv.id,c.content_key,cpi.transliterated_title,cpi.arabic_title,c.created_at"
	return fields, join, Where, groupBy
}
func GetMovieTrailerQuery(language string) (string, string, string) {
	fields := "vt.id,vt.content_variance_id as variance_id,c.id as content_id,c.content_tier,vt.video_trailer_id as video_id,vt.duration as length"
	if language == "en" {
		fields += ",vt.english_title as title"
	} else {
		fields += ",vt.arabic_title as title"
	}
	join := "join content_variance cv on cv.id = vt.content_variance_id join content c on c.id = cv.content_id join playback_item pi2 on pi2.id =cv.playback_item_id join content_rights cr on cr.id = pi2.rights_id join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "c.content_key =? and crc.country_id =?"
	return fields, join, Where
}
func GetSeasonTrailerQuery(language string) (string, string, string) {
	fields := "vt.id,vt.season_id as variance_id,c.id as content_id,c.content_tier,vt.video_trailer_id as video_id,vt.duration as length"
	if language == "en" {
		fields += ",vt.english_title as title"
	} else {
		fields += ",vt.arabic_title as title"
	}
	join := "join season s on s.id = vt.season_id join content c on c.id = s.content_id join content_rights cr on cr.id = s.rights_id join content_rights_country crc on crc.content_rights_id =cr.id"
	Where := "s.season_key =? and crc.country_id =?"
	return fields, join, Where
}
func ContentTagsQuery() (string, string, string, string) {
	fields := "tdt.name"
	join := "join content_tag ct on ct.textual_data_tag_id =tdt.id join content c on c.tag_info_id = ct.tag_info_id"
	Where := "c.id =?"
	groupBy := "tdt.name"
	return fields, join, Where, groupBy
}
func MeadiaObjectQuery(language string) string {
	fields := "atci.age_group::text as age_rating,lower(c.content_type) as content_type,REPLACE (lower(cpi.transliterated_title), ' ', '-') as friendly_url,c.content_key as id,c.created_at as inserted_at,min(pi1.duration) as length,min(pi1.video_content_id) as video_id,c.id as content_id,c.content_tier"
	fields2 := "atci.age_group::text as age_rating,lower(c.content_type) as content_type,REPLACE (lower(cpi.transliterated_title), ' ', '-') as friendly_url,c.content_key as id,c.created_at as inserted_at,min(pi1.duration) as length,min(pi1.video_content_id) as video_id,c.id as content_id,c.content_tier"
	if language == "en" {
		fields += ",cpi.transliterated_title as title"
	} else {
		fields += ",cpi.arabic_title as title"
	}
	if language == "en" {
		fields2 += ",cpi2.transliterated_title as title"
	} else {
		fields2 += ",cpi2.arabic_title as title"
	}
	query := "SELECT " + fields + ",min(cv.id::text) as variance_id from content c join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and c.content_key in(?) group by c.content_type,c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,atci.age_group,cpi.arabic_title UNION SELECT " + fields2 + ",min(s.id::text) as variance_id from content c 	join content_primary_info cpi2 on cpi2.id = c.primary_info_id join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null and c.content_key in(?) group by c.content_type,c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,cpi2.transliterated_title,atci.age_group,cpi.arabic_title,cpi2.arabic_title"
	return query
}

func EpisodeMeadiaObjectQuery(language string) string {
	fields := "e.episode_key as id,c.content_key as series_id,s.number as season_number,atci.age_group as age_rating,s.season_key as season_id,e.number as episode_number,'episode' as content_type,c.content_key as id,e.episode_key,c.created_at as inserted_at,min(pi1.duration) as length,min(pi1.video_content_id) as video_id,c.id as content_id,c.content_tier,min(s.id::text) as variance_id,e.id as episode_id"
	if language == "en" {
		fields += ",cpi2.transliterated_title as series_title,cpi.transliterated_title as title,cpi.arabic_title as translated_title"
	} else {
		fields += ",cpi.arabic_title as series_title,cpi.arabic_title as title,cpi.transliterated_title as translated_title"
	}
	query := "SELECT " + fields + " from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi2 on cpi2.id = c.primary_info_id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=e.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null and e.episode_key in(?) group by c.content_type,c.content_key,c.id,c.content_tier,c.created_at,cpi2.transliterated_title,cpi.transliterated_title,atci.age_group,e.episode_key,s.number,s.season_key,e.number,e.id,cpi.arabic_title"
	return query
}
func RelatedContentsQuery(queryType int, genre1, genre2, sgenre1, sgenre2, originalLang string, country int, limit string, language string, contentKey string) string {
	fields := ""
	if language == "en" {
		fields = "cpi.transliterated_title as title,cpi.transliterated_title as friendly_url"
	} else {
		fields = "cpi.arabic_title as title,cpi.transliterated_title as friendly_url"
	}
	countryId := strconv.Itoa(country)
	query := ""
	if queryType == 1 {
		/*query = "SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type,cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null  and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=" + countryId + " and cg.genre_id::text ='" + genre1 + "' and cg.genre_id::text ='" + genre2 + "' and cs.subgenre_id::text ='" + sgenre1 + "' and cs.subgenre_id::text ='" + sgenre2 + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,cv.id,cpi.arabic_title UNION SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null  and crc.country_id=" + countryId + " and cg.genre_id::text ='" + genre1 + "' and cg.genre_id::text ='" + genre2 + "' and cs.subgenre_id::text ='" + sgenre1 + "' and cs.subgenre_id::text ='" + sgenre2 + "'  group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,s.id,cpi.arabic_title  order by id limit " + limit + ""*/
		query = "((SELECT distinct on(c.content_key)c.content_key,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type,cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content  c join content_genre  cg on cg.content_id = c.id join content_subgenre  cs on cs.content_genre_id = cg.id join content_genre  cg1 on cg1.content_id = c.id join content_subgenre cs1 on cs1.content_genre_id = cg1.id join content_primary_info cpi on cpi.id = c.primary_info_id join about_the_content_info atci on atci.id = c.about_the_content_info_id join content_variance  cv on cv.content_id = c.id join playback_item pi1 on pi1.id = cv.playback_item_id join content_rights cr on cr.id = pi1.rights_id join content_translation ct on ct.id = pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id  = cr.id full outer join content_rights_plan crp on crp.rights_id  = cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id  is null and ( pi1.scheduling_date_time  <= now() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date  <= now() or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now() or cr.digital_rights_end_date  is null) and crc.country_id  = " + countryId + " and cg.genre_id ::text = '" + genre1 + "' and cs.subgenre_id ::text = '" + sgenre1 + "' and cg.order  = 1 and cg1.genre_id ::text = '" + genre2 + "' and cs1.subgenre_id ::text = '" + sgenre2 + "' and cg1.order = 2 group by c.content_key,c.id,c.content_type ,cr.digital_rights_type ,c.content_tier,c.created_at,cg.genre_id,cpi.transliterated_title,cv.id,cpi.arabic_title,pi1.video_content_id) union(SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type,cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre  cg on cg.content_id  = c.id join content_subgenre cs on cs.content_genre_id = cg.id join content_genre cg1 on cg1.content_id = c.id join content_subgenre cs1 on cs1.content_genre_id  = cg1.id join season s on s.content_id = c.id join episode e on e.season_id = s.id join content_primary_info cpi on cpi.id = s.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join playback_item pi1 on pi1.id = e.playback_item_id join content_rights  cr on cr.id = pi1.rights_id join content_translation ct on ct.id = pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id = cr.id full outer join content_rights_plan crp on crp.rights_id = cr.id where c.content_key !=" + contentKey + "and  c.status = 1 and c.deleted_by_user_id  is null and ( pi1.scheduling_date_time  <= now() or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now() or cr.digital_rights_start_date  is null)and (cr.digital_rights_end_date  >= now() or cr.digital_rights_end_date  is null) and s.status = 1 and s.deleted_by_user_id  is null and e.status = 1 and e.deleted_by_user_id  is null and crc.country_id  = " + countryId + " and cg.genre_id::text  = '" + genre1 + "' and cs.subgenre_id::text  = '" + sgenre1 + "' and cg.order  = 1 and cg1.genre_id::text = '" + genre2 + "' and cs1.subgenre_id::text = '" + sgenre2 + "'and cg1.order  = 2 group by c.content_key,c.id,c.content_type,cr.digital_rights_type,c.content_tier,c.created_at,cg.genre_id,cpi.transliterated_title,s.id,cpi.arabic_title)) order by created_at,content_type  desc OFFSET 0 ROWS FETCH NEXT " + limit + " ROWS ONLY"

	} else if queryType == 2 {
		/*query = "SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null  and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=" + countryId + " and cg.genre_id::text = '" + genre1 + "' and cg.genre_id::text = '" + genre2 + "' and cs.subgenre_id::text ='" + sgenre1 + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,cv.id,cpi.arabic_title UNION SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null  and crc.country_id=" + countryId + " and cg.genre_id::text = '" + genre1 + "' and cg.genre_id::text = '" + genre2 + "' and cs.subgenre_id::text ='" + sgenre1 + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,s.id,cpi.arabic_title   order by id limit " + limit + ""*/
		query = "(select distinct on(c.content_key)c.content_key,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_genre cg1 on cg1.content_id  =c.id join content_subgenre cs1 on cs1.content_genre_id = cg1.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id  join content_variance  cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id  join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id  full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and  c.status = 1 and c.deleted_by_user_id  is null and ( pi1.scheduling_date_time  <= now()  or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now()  or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now()  or cr.digital_rights_end_date  is null) and crc.country_id = " + countryId + " and cg.genre_id  = '" + genre1 + "' and cs.subgenre_id  = '" + sgenre1 + "' and cg.order = 1 and  cg1.genre_id  = '" + genre2 + "' and cg1.order=2 group by c.content_key ,c.id,c.content_type ,cr.digital_rights_type ,c.content_tier ,c.created_at ,cg.genre_id ,cpi.transliterated_title,cv.id,cpi.arabic_title ,pi1.video_content_id UNION SELECT distinct c.content_key as id,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id  =cg.id join content_genre cg1 on cg1.content_id  =c.id join content_subgenre cs1 on cs1.content_genre_id  =cg1.id join season s on s.content_id = c.id join episode e on e.season_id = s.id join content_primary_info cpi on cpi.id = s.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join playback_item pi1 on pi1.id = e.playback_item_id join content_rights cr on cr.id = pi1.rights_id join content_translation ct on ct.id = pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id = cr.id full outer join content_rights_plan crp on crp.rights_id = cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= now() or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now() or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now() or cr.digital_rights_end_date  is null) and s.status = 1 and s.deleted_by_user_id  is null and e.status = 1 and e.deleted_by_user_id  is null and crc.country_id = " + countryId + " and  cg.genre_id = '" + genre1 + "' and  cs.subgenre_id = '" + sgenre1 + "' and cg.order=1 and  cg1.genre_id = '" + genre2 + "' and cg1.order=2 group by c.content_key,c.id,c.content_type,cr.digital_rights_type,c.content_tier,c.created_at,cg.genre_id,cpi.transliterated_title,s.id,cpi.arabic_title)order by created_at,content_type desc OFFSET 0 ROWS FETCH next " + limit + " ROWS ONLY"

	} else if queryType == 3 {
		/*query = "SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null  and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=" + countryId + " and cg.genre_id::text = '" + genre1 + "' and cs.subgenre_id::text ='" + sgenre1 + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,cv.id,cpi.arabic_title UNION SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null  and crc.country_id=" + countryId + " and cg.genre_id::text = '" + genre1 + "' and cs.subgenre_id::text ='" + sgenre1 + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,s.id,cpi.arabic_title   order by id limit " + limit + ""*/
		query = "(select distinct on(c.content_key)c.content_key,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id  join content_variance  cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id  join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id  full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id  is null and ( pi1.scheduling_date_time  <= now()  or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now()  or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now()  or cr.digital_rights_end_date  is null) and crc.country_id = " + countryId + " and cg.genre_id  = '" + genre1 + "' and cs.subgenre_id  = '" + sgenre1 + "' and cg.order = 1 group by c.content_key ,c.id,c.content_type ,cr.digital_rights_type ,c.content_tier ,c.created_at ,cg.genre_id ,cpi.transliterated_title,cv.id,cpi.arabic_title ,pi1.video_content_id UNION SELECT distinct c.content_key as id,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id  =cg.id join season s on s.content_id = c.id join episode e on e.season_id = s.id join content_primary_info cpi on cpi.id = s.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join playback_item pi1 on pi1.id = e.playback_item_id join content_rights cr on cr.id = pi1.rights_id join content_translation ct on ct.id = pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id = cr.id full outer join content_rights_plan crp on crp.rights_id = cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= now() or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now() or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now() or cr.digital_rights_end_date  is null) and s.status = 1 and s.deleted_by_user_id  is null and e.status = 1 and e.deleted_by_user_id  is null and crc.country_id = " + countryId + " and  cg.genre_id = '" + genre1 + "' and  cs.subgenre_id = '" + sgenre1 + "' and cg.order=1 group by c.content_key,c.id,c.content_type,cr.digital_rights_type,c.content_tier,c.created_at,cg.genre_id,cpi.transliterated_title,s.id,cpi.arabic_title)order by created_at,content_type desc OFFSET 0 ROWS FETCH next " + limit + " ROWS ONLY"
	} else if queryType == 4 {
		/*query = "SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null  and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and crc.country_id=" + countryId + " and atci.original_language='" + originalLang + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,cv.id,cpi.arabic_title UNION SELECT c.content_key as id,c.id as content_id,c.content_tier,c.created_at," + fields + ",lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id =c.id join episode e on e.season_id =s.id join content_primary_info cpi on cpi.id=s.primary_info_id join about_the_content_info atci on atci.id=s.about_the_content_info_id join playback_item pi1 on pi1.id =e.playback_item_id join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= NOW() or pi1.scheduling_date_time is null) and (cr.digital_rights_start_date <=NOW() or cr.digital_rights_start_date is null) and (cr.digital_rights_end_date >=NOW() or cr.digital_rights_end_date is null) and s.status =1 and s.deleted_by_user_id is null and e.status =1 and e.deleted_by_user_id is null  and crc.country_id=" + countryId + " and atci.original_language='" + originalLang + "' group by c.content_key,c.id,c.content_tier,c.created_at,cpi.transliterated_title,c.content_type,cr.digital_rights_type,cg.genre_id,s.id,cpi.arabic_title   order by id limit " + limit + ""*/
		query = "(select distinct on(c.content_key)c.content_key,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,cv.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id =cg.id join content_primary_info cpi on cpi.id=c.primary_info_id join about_the_content_info atci on atci.id=c.about_the_content_info_id  join content_variance  cv on cv.content_id =c.id join playback_item pi1 on pi1.id =cv.playback_item_id  join content_rights cr on cr.id=pi1.rights_id join content_translation ct on ct.id=pi1.translation_id  full outer join content_rights_country crc on crc.content_rights_id =cr.id full outer join content_rights_plan crp on crp.rights_id =cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id  is null and ( pi1.scheduling_date_time  <= now()  or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now()  or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now()  or cr.digital_rights_end_date  is null) and crc.country_id = " + countryId + " and atci.original_language = '" + originalLang + "' group by c.content_key ,c.id,c.content_type ,cr.digital_rights_type ,c.content_tier ,c.created_at ,cg.genre_id ,cpi.transliterated_title,cv.id,cpi.arabic_title ,pi1.video_content_id UNION SELECT distinct c.content_key as id,c.id as content_id,c.content_tier,c.created_at,cpi.transliterated_title as title,cpi.transliterated_title as friendly_url,lower(c.content_type) as content_type, cr.digital_rights_type,s.id as season_or_varience_id,min(pi1.video_content_id) as video_id from content c join content_genre cg on cg.content_id  =c.id join content_subgenre cs on cs.content_genre_id  =cg.id join season s on s.content_id = c.id join episode e on e.season_id = s.id join content_primary_info cpi on cpi.id = s.primary_info_id join about_the_content_info atci on atci.id = s.about_the_content_info_id join playback_item pi1 on pi1.id = e.playback_item_id join content_rights cr on cr.id = pi1.rights_id join content_translation ct on ct.id = pi1.translation_id full outer join content_rights_country crc on crc.content_rights_id = cr.id full outer join content_rights_plan crp on crp.rights_id = cr.id where c.content_key not in (?) and c.content_key !=" + contentKey + "and c.status = 1 and c.deleted_by_user_id is null and ( pi1.scheduling_date_time  <= now() or pi1.scheduling_date_time  is null) and (cr.digital_rights_start_date  <= now() or cr.digital_rights_start_date  is null) and (cr.digital_rights_end_date  >= now() or cr.digital_rights_end_date  is null) and s.status = 1 and s.deleted_by_user_id  is null and e.status = 1 and e.deleted_by_user_id  is null and crc.country_id = " + countryId + " and atci.original_language = '" + originalLang + "' group by c.content_key,c.id,c.content_type,cr.digital_rights_type,c.content_tier,c.created_at,cg.genre_id,cpi.transliterated_title,s.id,cpi.arabic_title)order by created_at,content_type desc OFFSET 0 ROWS FETCH next " + limit + " ROWS ONLY"
	}
	return query
}
func GetRelatedContentGenreQuery() string {
	query := "(select distinct on (cg.genre_id)cg.genre_id,atci.original_language,cs.subgenre_id,cg.order as order1 from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join about_the_content_info atci on atci.id=c.about_the_content_info_id where c.content_key = ? group  by atci.original_language,cg.genre_id,cs.subgenre_id,cg.order,cs.order union select distinct on (cg.genre_id)cg.genre_id,atci.original_language,cs.subgenre_id,cg.order as order1 from content c join content_genre cg on cg.content_id =c.id join content_subgenre cs on cs.content_genre_id =cg.id join season s on s.content_id = c.id join about_the_content_info atci on atci.id=s.about_the_content_info_id where c.content_key = ? group  by atci.original_language,cg.genre_id,cs.subgenre_id,cg.order,cs.order )order by order1"
	return query
}
func ViewActivityDetailsQuery() (string, string, string) {
	fields := "va.viewed_at,va.last_watch_position,e.episode_key,'Episode' as content_type,pi1.duration"
	join := "join episode e on e.playback_item_id = va.playback_item_id join playback_item pi1 on pi1.id =e.playback_item_id"
	where := "va.content_id =? and va.user_id =? and va.is_hidden=false"
	return fields, join, where
}
func GetWatchingContentDetailsQuery(contentKey int) string {
	contentid := strconv.Itoa(contentKey)
	query := "select c.id,pi1.id as playback_item_id from content c join content_variance cv on cv.content_id =c.id join playback_item pi1 on pi1.id = cv.playback_item_id where c.content_key =" + contentid + " union select c.id,pi1.id as playback_item_id from content c join season s on s.content_id =c.id join episode e on e.season_id = s.id join playback_item pi1 on pi1.id = e.playback_item_id where e.episode_key =" + contentid + ""
	return query
}
func SearchContentByCastQuery(searchText string) string {
	query := "select c.id, c.content_type,c.content_key,c.content_tier from content c join content_actor ca on ca.cast_id=c.cast_id join actor a on a.id=ca.actor_id where c.deleted_by_user_id is null and c.status=1 and (lower(a.english_name) like '%" + searchText + "%' or lower(a.arabic_name) like '%" + searchText + "%') union select c.id, c.content_type,c.content_key,c.content_tier from content c join content_cast cc on cc.id=c.cast_id join actor a on (a.id=cc.main_actor_id or a.id =cc.main_actress_id ) where c.deleted_by_user_id is null and c.status=1 and (lower(a.english_name) like '%" + searchText + "%' or lower(a.arabic_name) like '%" + searchText + "%') union select c.id, c.content_type,c.content_key,c.content_tier from content c join season s on s.content_id=c.id join content_actor ca on ca.cast_id=s.cast_id join actor a on a.id=ca.actor_id where c.deleted_by_user_id is null and c.status=1 and (lower(a.english_name) like '%" + searchText + "%' or lower(a.arabic_name) like '%" + searchText + "%') union select c.id, c.content_type,c.content_key,c.content_tier from content c join season s on s.content_id=c.id  join content_cast cc on cc.id=s.cast_id join actor a on (a.id=cc.main_actor_id or a.id =cc.main_actress_id ) where c.deleted_by_user_id is null and c.status=1 and (lower(a.english_name) like '%" + searchText + "%' or lower(a.arabic_name) like '%" + searchText + "%')"
	return query
}
func SearchContentByCastIdQuery() string {
	query := "select c.id, c.content_type,c.content_key,c.content_tier from content c join content_actor ca on ca.cast_id=c.cast_id join actor a on a.id=ca.actor_id where c.deleted_by_user_id is null and c.status=1 and a.id in(?) union select c.id, c.content_type,c.content_key,c.content_tier from content c join content_cast cc on cc.id=c.cast_id join actor a on (a.id=cc.main_actor_id or a.id =cc.main_actress_id ) where c.deleted_by_user_id is null and c.status=1 and a.id in(?) union select c.id, c.content_type,c.content_key,c.content_tier from content c join season s on s.content_id=c.id join content_actor ca on ca.cast_id=s.cast_id join actor a on a.id=ca.actor_id where c.deleted_by_user_id is null and c.status=1 and a.id in(?) union select c.id, c.content_type,c.content_key,c.content_tier from content c join season s on s.content_id=c.id  join content_cast cc on cc.id=s.cast_id join actor a on (a.id=cc.main_actor_id or a.id =cc.main_actress_id ) where c.deleted_by_user_id is null and c.status=1 and a.id in(?)"
	return query
}
func ResumbleContentsQuery() string {
	query := "select c.id as content_id,round(c.average_rating::numeric,1) AS average_rating,cpi.transliterated_title as title,INITCAP(c.content_type) as content_type,cr.digital_rights_type,min(pi2.duration) as duration,c.content_key as id,va.viewed_at,va.last_watch_position from content c join content_primary_info cpi on cpi.id =c.primary_info_id join view_activity va on va.content_id = c.id join playback_item pi2 on pi2.id = va.playback_item_id join content_rights cr on cr.id =pi2.rights_id WHERE va.user_id=? and va.is_hidden =false and c.content_tier=1 and va.last_watch_position*100/pi2.duration <95 and va.last_watch_position != 0 group by c.average_rating,c.content_type,c.content_key,cpi.transliterated_title,c.content_tier,cr.digital_rights_type,c.id,va.viewed_at,va.last_watch_position union select c.id as content_id,round(c.average_rating::numeric,1) AS average_rating,cpi.transliterated_title as title,'Episode' as content_type,cr.digital_rights_type,min(pi2.duration) as duration,e.episode_key as id,va.viewed_at,va.last_watch_position from content c join view_activity va on va.content_id = c.id join playback_item pi2 on pi2.id = va.playback_item_id join content_rights cr on cr.id =pi2.rights_id left join episode e on e.playback_item_id = va.playback_item_id join content_primary_info cpi on cpi.id =e.primary_info_id WHERE va.user_id=? and va.is_hidden =false and c.content_tier =2 and va.last_watch_position*100/pi2.duration <95 and va.last_watch_position != 0 group by c.average_rating,c.content_type,c.content_key,cpi.transliterated_title,c.content_tier,cr.digital_rights_type,c.id,va.viewed_at,va.last_watch_position,e.episode_key"
	return query
}
